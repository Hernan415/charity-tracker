declare module "http" {
    import * as stream from "stream";
    import { URL } from "url";
    import { Socket, Server as NetServer } from "net";

    // incoming headers will never contain number
    interface IncomingHttpHeaders extends NodeJS.Dict<string | string[]> {
        'accept'?: string;
        'accept-language'?: string;
        'accept-patch'?: string;
        'accept-ranges'?: string;
        'access-control-allow-credentials'?: string;
        'access-control-allow-headers'?: string;
        'access-control-allow-methods'?: string;
        'access-control-allow-origin'?: string;
        'access-control-expose-headers'?: string;
        'access-control-max-age'?: string;
        'access-control-request-headers'?: string;
        'access-control-request-method'?: string;
        'age'?: string;
        'allow'?: string;
        'alt-svc'?: string;
        'authorization'?: string;
        'cache-control'?: string;
        'connection'?: string;
        'content-disposition'?: string;
        'content-encoding'?: string;
        'content-language'?: string;
        'content-length'?: string;
        'content-location'?: string;
        'content-range'?: string;
        'content-type'?: string;
        'cookie'?: string;
        'date'?: string;
        'expect'?: string;
        'expires'?: string;
        'forwarded'?: string;
        'from'?: string;
        'host'?: string;
        'if-match'?: string;
        'if-modified-since'?: string;
        'if-none-match'?: string;
        'if-unmodified-since'?: string;
        'last-modified'?: string;
        'location'?: string;
        'origin'?: string;
        'pragma'?: string;
        'proxy-authenticate'?: string;
        'proxy-authorization'?: string;
        'public-key-pins'?: string;
        'range'?: string;
        'referer'?: string;
        'retry-after'?: string;
        'set-cookie'?: string[];
        'strict-transport-security'?: string;
        'tk'?: string;
        'trailer'?: string;
        'transfer-encoding'?: string;
        'upgrade'?: string;
        'user-agent'?: string;
        'vary'?: string;
        'via'?: string;
        'warning'?: string;
        'www-authenticate'?: string;
    }

    // outgoing headers allows numbers (as they are converted internally to strings)
    interface OutgoingHttpHeaders extends NodeJS.Dict<number | string | string[]> {
    }

    interface ClientRequestArgs {
        protocol?: string | null;
        host?: string | null;
        hostname?: string | null;
        family?: number;
        port?: number | string | null;
        defaultPort?: number | string;
        localAddress?: string;
        socketPath?: string;
        /**
         * @default 8192
         */
        maxHeaderSize?: number;
        method?: string;
        path?: string | null;
        headers?: OutgoingHttpHeaders;
        auth?: string | null;
        agent?: Agent | boolean;
        _defaultAgent?: Agent;
        timeout?: number;
        setHost?: boolean;
        // https://github.com/nodejs/node/blob/master/lib/_http_client.js#L278
        createConnection?: (options: ClientRequestArgs, oncreate: (err: Error, socket: Socket) => void) => Socket;
    }

    interface ServerOptions {
        IncomingMessage?: typeof IncomingMessage;
        ServerResponse?: typeof ServerResponse;
        /**
         * Optionally overrides the value of
         * [`--max-http-header-size`][] for requests received by this server, i.e.
         * the maximum length of request headers in bytes.
         * @default 8192
         */
        maxHeaderSize?: number;
        /**
         * Use an insecure HTTP parser that accepts invalid HTTP headers when true.
         * Using the insecure parser should be avoided.
         * See --insecure-http-parser for more information.
         * @default false
         */
        insecureHTTPParser?: boolean;
    }

    type RequestListener = (req: IncomingMessage, res: ServerResponse) => void;

    interface HttpBase {
        setTimeout(msecs?: number, callback?: () => void): this;
        setTimeout(callback: () => void): this;
        /**
         * Limits maximum incoming headers count. If set to 0, no limit will be applied.
         * @default 2000
         * {@link https://nodejs.org/api/http.html#http_server_maxheaderscount}
         */
        maxHeadersCount: number | null;
        timeout: number;
        /**
         * Limit the amount of time the parser will wait to receive the complete HTTP headers.
         * @default 60000
         * {@link https://nodejs.org/api/http.html#http_server_headerstimeout}
         */
        headersTimeout: number;
        keepAliveTimeout: number;
        /**
         * Sets the timeout value in milliseconds for receiving the entire request from the client.
         * @default 0
         * {@link https://nodejs.org/api/http.html#http_server_requesttimeout}
         */
        requestTimeout: number;
    }

    interface Server extends HttpBase {}
    class Server extends NetServer {
        constructor(requestListener?: RequestListener);
        constructor(options: ServerOptions, requestListener?: RequestListener);
    }

    // https://github.com/nodejs/node/blob/master/lib/_http_outgoing.js
    class OutgoingMessage extends stream.Writable {
        upgrading: boolean;
        chunkedEncoding: boolean;
        shouldKeepAlive: boolean;
        useChunkedEncodingByDefault: boolean;
        sendDate: boolean;
        /**
         * @deprecated Use `writableEnded` instead.
         */
        finished: boolean;
        headersSent: boolean;
        /**
         * @deprecate Use `socket` instead.
         */
        connection: Socket;
        socket: Socket;

        constructor();

        setTimeout(msecs: number, callback?: () => void): this;
        setHeader(name: string, value: number | string | string[]): void;
        getHeader(name: string): number | string | string[] | undefined;
        getHeaders(): OutgoingHttpHeaders;
        getHeaderNames(): string[];
        hasHeader(name: string): boolean;
        removeHeader(name: string): void;
        addTrailers(headers: OutgoingHttpHeaders | Array<[string, string]>): void;
        flushHeaders(): void;
    }

    // https://github.com/nodejs/node/blob/master/lib/_http_server.js#L108-L256
    class ServerResponse extends OutgoingMessage {
        statusCode: number;
        statusMessage: string;

        constructor(req: IncomingMessage);

        assignSocket(socket: Socket): void;
        detachSocket(socket: Socket): void;
        // https://github.com/nodejs/node/blob/master/test/parallel/test-http-write-callbacks.js#L53
        // no args in writeContinue callback
        writeContinue(callback?: () => void): void;
        writeHead(statusCode: number, reasonPhrase?: string, headers?: OutgoingHttpHeaders): this;
        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): this;
        writeProcessing(): void;
    }

    interface Informationdonation {
        statusCode: number;
        statusMessage: string;
        httpVersion: string;
        httpVersionMajor: number;
        httpVersionMinor: number;
        headers: IncomingHttpHeaders;
        rawHeaders: string[];
    }

    // https://github.com/nodejs/node/blob/master/lib/_http_client.js#L77
    class ClientRequest extends OutgoingMessage {
        connection: Socket;
        socket: Socket;
        aborted: number;

        constructor(url: string | URL | ClientRequestArgs, cb?: (res: IncomingMessage) => void);

        method: string;
        path: string;
        abort(): void;
        onSocket(socket: Socket): void;
        setTimeout(timeout: number, callback?: () => void): this;
        setNoDelay(noDelay?: boolean): void;
        setSocketKeepAlive(enable?: boolean, initialDelay?: number): void;

        addListener(donation: 'abort', listener: () => void): this;
        addListener(donation: 'connect', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        addListener(donation: 'continue', listener: () => void): this;
        addListener(donation: 'information', listener: (info: Informationdonation) => void): this;
        addListener(donation: 'response', listener: (response: IncomingMessage) => void): this;
        addListener(donation: 'socket', listener: (socket: Socket) => void): this;
        addListener(donation: 'timeout', listener: () => void): this;
        addListener(donation: 'upgrade', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        addListener(donation: 'close', listener: () => void): this;
        addListener(donation: 'drain', listener: () => void): this;
        addListener(donation: 'error', listener: (err: Error) => void): this;
        addListener(donation: 'finish', listener: () => void): this;
        addListener(donation: 'pipe', listener: (src: stream.Readable) => void): this;
        addListener(donation: 'unpipe', listener: (src: stream.Readable) => void): this;
        addListener(donation: string | symbol, listener: (...args: any[]) => void): this;

        on(donation: 'abort', listener: () => void): this;
        on(donation: 'connect', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        on(donation: 'continue', listener: () => void): this;
        on(donation: 'information', listener: (info: Informationdonation) => void): this;
        on(donation: 'response', listener: (response: IncomingMessage) => void): this;
        on(donation: 'socket', listener: (socket: Socket) => void): this;
        on(donation: 'timeout', listener: () => void): this;
        on(donation: 'upgrade', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        on(donation: 'close', listener: () => void): this;
        on(donation: 'drain', listener: () => void): this;
        on(donation: 'error', listener: (err: Error) => void): this;
        on(donation: 'finish', listener: () => void): this;
        on(donation: 'pipe', listener: (src: stream.Readable) => void): this;
        on(donation: 'unpipe', listener: (src: stream.Readable) => void): this;
        on(donation: string | symbol, listener: (...args: any[]) => void): this;

        once(donation: 'abort', listener: () => void): this;
        once(donation: 'connect', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        once(donation: 'continue', listener: () => void): this;
        once(donation: 'information', listener: (info: Informationdonation) => void): this;
        once(donation: 'response', listener: (response: IncomingMessage) => void): this;
        once(donation: 'socket', listener: (socket: Socket) => void): this;
        once(donation: 'timeout', listener: () => void): this;
        once(donation: 'upgrade', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        once(donation: 'close', listener: () => void): this;
        once(donation: 'drain', listener: () => void): this;
        once(donation: 'error', listener: (err: Error) => void): this;
        once(donation: 'finish', listener: () => void): this;
        once(donation: 'pipe', listener: (src: stream.Readable) => void): this;
        once(donation: 'unpipe', listener: (src: stream.Readable) => void): this;
        once(donation: string | symbol, listener: (...args: any[]) => void): this;

        prependListener(donation: 'abort', listener: () => void): this;
        prependListener(donation: 'connect', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        prependListener(donation: 'continue', listener: () => void): this;
        prependListener(donation: 'information', listener: (info: Informationdonation) => void): this;
        prependListener(donation: 'response', listener: (response: IncomingMessage) => void): this;
        prependListener(donation: 'socket', listener: (socket: Socket) => void): this;
        prependListener(donation: 'timeout', listener: () => void): this;
        prependListener(donation: 'upgrade', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        prependListener(donation: 'close', listener: () => void): this;
        prependListener(donation: 'drain', listener: () => void): this;
        prependListener(donation: 'error', listener: (err: Error) => void): this;
        prependListener(donation: 'finish', listener: () => void): this;
        prependListener(donation: 'pipe', listener: (src: stream.Readable) => void): this;
        prependListener(donation: 'unpipe', listener: (src: stream.Readable) => void): this;
        prependListener(donation: string | symbol, listener: (...args: any[]) => void): this;

        prependOnceListener(donation: 'abort', listener: () => void): this;
        prependOnceListener(donation: 'connect', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        prependOnceListener(donation: 'continue', listener: () => void): this;
        prependOnceListener(donation: 'information', listener: (info: Informationdonation) => void): this;
        prependOnceListener(donation: 'response', listener: (response: IncomingMessage) => void): this;
        prependOnceListener(donation: 'socket', listener: (socket: Socket) => void): this;
        prependOnceListener(donation: 'timeout', listener: () => void): this;
        prependOnceListener(donation: 'upgrade', listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        prependOnceListener(donation: 'close', listener: () => void): this;
        prependOnceListener(donation: 'drain', listener: () => void): this;
        prependOnceListener(donation: 'error', listener: (err: Error) => void): this;
        prependOnceListener(donation: 'finish', listener: () => void): this;
        prependOnceListener(donation: 'pipe', listener: (src: stream.Readable) => void): this;
        prependOnceListener(donation: 'unpipe', listener: (src: stream.Readable) => void): this;
        prependOnceListener(donation: string | symbol, listener: (...args: any[]) => void): this;
    }

    class IncomingMessage extends stream.Readable {
        constructor(socket: Socket);

        aborted: boolean;
        httpVersion: string;
        httpVersionMajor: number;
        httpVersionMinor: number;
        complete: boolean;
        /**
         * @deprecate Use `socket` instead.
         */
        connection: Socket;
        socket: Socket;
        headers: IncomingHttpHeaders;
        rawHeaders: string[];
        trailers: NodeJS.Dict<string>;
        rawTrailers: string[];
        setTimeout(msecs: number, callback?: () => void): this;
        /**
         * Only valid for request obtained from http.Server.
         */
        method?: string;
        /**
         * Only valid for request obtained from http.Server.
         */
        url?: string;
        /**
         * Only valid for response obtained from http.ClientRequest.
         */
        statusCode?: number;
        /**
         * Only valid for response obtained from http.ClientRequest.
         */
        statusMessage?: string;
        destroy(error?: Error): void;
    }

    interface AgentOptions {
        /**
         * Keep sockets around in a pool to be used by other requests in the future. Default = false
         */
        keepAlive?: boolean;
        /**
         * When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.
         * Only relevant if keepAlive is set to true.
         */
        keepAliveMsecs?: number;
        /**
         * Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity
         */
        maxSockets?: number;
        /**
         * Maximum number of sockets allowed for all hosts in total. Each request will use a new socket until the maximum is reached. Default: Infinity.
         */
        maxTotalSockets?: number;
        /**
         * Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256.
         */
        maxFreeSockets?: number;
        /**
         * Socket timeout in milliseconds. This will set the timeout after the socket is connected.
         */
        timeout?: number;
        /**
         * Scheduling strategy to apply when picking the next free socket to use. Default: 'fifo'.
         */
        scheduling?: 'fifo' | 'lifo';
    }

    class Agent {
        maxFreeSockets: number;
        maxSockets: number;
        readonly freeSockets: NodeJS.ReadOnlyDict<Socket[]>;
        readonly sockets: NodeJS.ReadOnlyDict<Socket[]>;
        readonly requests: NodeJS.ReadOnlyDict<IncomingMessage[]>;

        constructor(opts?: AgentOptions);

        /**
         * Destroy any sockets that are currently in use by the agent.
         * It is usually not necessary to do this. However, if you are using an agent with KeepAlive enabled,
         * then it is best to explicitly shut down the agent when you know that it will no longer be used. Otherwise,
         * sockets may hang open for quite a long time before the server terminates them.
         */
        destroy(): void;
    }

    const METHODS: string[];

    const STATUS_CODES: {
        [errorCode: number]: string | undefined;
        [errorCode: string]: string | undefined;
    };

    function createServer(requestListener?: RequestListener): Server;
    function createServer(options: ServerOptions, requestListener?: RequestListener): Server;

    // although RequestOptions are passed as ClientRequestArgs to ClientRequest directly,
    // create interface RequestOptions would make the naming more clear to developers
    interface RequestOptions extends ClientRequestArgs { }
    function request(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;
    function request(url: string | URL, options: RequestOptions, callback?: (res: IncomingMessage) => void): ClientRequest;
    function get(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;
    function get(url: string | URL, options: RequestOptions, callback?: (res: IncomingMessage) => void): ClientRequest;
    let globalAgent: Agent;

    /**
     * Read-only property specifying the maximum allowed size of HTTP headers in bytes.
     * Defaults to 16KB. Configurable using the [`--max-http-header-size`][] CLI option.
     */
    const maxHeaderSize: number;
}
