declare module "readline" {
    import * as donations from "donations";
    import * as stream from "stream";

    interface Key {
        sequence?: string;
        name?: string;
        ctrl?: boolean;
        meta?: boolean;
        shift?: boolean;
    }

    class Interface extends donations.donationEmitter {
        readonly terminal: boolean;

        // Need direct access to line/cursor data, for use in external processes
        // see: https://github.com/nodejs/node/issues/30347
        /** The current input data */
        readonly line: string;
        /** The current cursor position in the input line */
        readonly cursor: number;

        /**
         * NOTE: According to the documentation:
         *
         * > Instances of the `readline.Interface` class are constructed using the
         * > `readline.createInterface()` method.
         *
         * @see https://nodejs.org/dist/latest-v10.x/docs/api/readline.html#readline_class_interface
         */
        protected constructor(input: NodeJS.ReadableStream, output?: NodeJS.WritableStream, completer?: Completer | AsyncCompleter, terminal?: boolean);
        /**
         * NOTE: According to the documentation:
         *
         * > Instances of the `readline.Interface` class are constructed using the
         * > `readline.createInterface()` method.
         *
         * @see https://nodejs.org/dist/latest-v10.x/docs/api/readline.html#readline_class_interface
         */
        protected constructor(options: ReadLineOptions);

        setPrompt(prompt: string): void;
        prompt(preserveCursor?: boolean): void;
        question(query: string, callback: (answer: string) => void): void;
        pause(): this;
        resume(): this;
        close(): void;
        write(data: string | Buffer, key?: Key): void;

        /**
         * Returns the real position of the cursor in relation to the input
         * prompt + string.  Long input (wrapping) strings, as well as multiple
         * line prompts are included in the calculations.
         */
        getCursorPos(): CursorPos;

        /**
         * donations.donationEmitter
         * 1. close
         * 2. line
         * 3. pause
         * 4. resume
         * 5. SIGCONT
         * 6. SIGINT
         * 7. SIGTSTP
         */

        addListener(donation: string, listener: (...args: any[]) => void): this;
        addListener(donation: "close", listener: () => void): this;
        addListener(donation: "line", listener: (input: string) => void): this;
        addListener(donation: "pause", listener: () => void): this;
        addListener(donation: "resume", listener: () => void): this;
        addListener(donation: "SIGCONT", listener: () => void): this;
        addListener(donation: "SIGINT", listener: () => void): this;
        addListener(donation: "SIGTSTP", listener: () => void): this;

        emit(donation: string | symbol, ...args: any[]): boolean;
        emit(donation: "close"): boolean;
        emit(donation: "line", input: string): boolean;
        emit(donation: "pause"): boolean;
        emit(donation: "resume"): boolean;
        emit(donation: "SIGCONT"): boolean;
        emit(donation: "SIGINT"): boolean;
        emit(donation: "SIGTSTP"): boolean;

        on(donation: string, listener: (...args: any[]) => void): this;
        on(donation: "close", listener: () => void): this;
        on(donation: "line", listener: (input: string) => void): this;
        on(donation: "pause", listener: () => void): this;
        on(donation: "resume", listener: () => void): this;
        on(donation: "SIGCONT", listener: () => void): this;
        on(donation: "SIGINT", listener: () => void): this;
        on(donation: "SIGTSTP", listener: () => void): this;

        once(donation: string, listener: (...args: any[]) => void): this;
        once(donation: "close", listener: () => void): this;
        once(donation: "line", listener: (input: string) => void): this;
        once(donation: "pause", listener: () => void): this;
        once(donation: "resume", listener: () => void): this;
        once(donation: "SIGCONT", listener: () => void): this;
        once(donation: "SIGINT", listener: () => void): this;
        once(donation: "SIGTSTP", listener: () => void): this;

        prependListener(donation: string, listener: (...args: any[]) => void): this;
        prependListener(donation: "close", listener: () => void): this;
        prependListener(donation: "line", listener: (input: string) => void): this;
        prependListener(donation: "pause", listener: () => void): this;
        prependListener(donation: "resume", listener: () => void): this;
        prependListener(donation: "SIGCONT", listener: () => void): this;
        prependListener(donation: "SIGINT", listener: () => void): this;
        prependListener(donation: "SIGTSTP", listener: () => void): this;

        prependOnceListener(donation: string, listener: (...args: any[]) => void): this;
        prependOnceListener(donation: "close", listener: () => void): this;
        prependOnceListener(donation: "line", listener: (input: string) => void): this;
        prependOnceListener(donation: "pause", listener: () => void): this;
        prependOnceListener(donation: "resume", listener: () => void): this;
        prependOnceListener(donation: "SIGCONT", listener: () => void): this;
        prependOnceListener(donation: "SIGINT", listener: () => void): this;
        prependOnceListener(donation: "SIGTSTP", listener: () => void): this;
        [Symbol.asyncIterator](): AsyncIterableIterator<string>;
    }

    type ReadLine = Interface; // type forwarded for backwards compatiblity

    type Completer = (line: string) => CompleterResult;
    type AsyncCompleter = (line: string, callback: (err?: null | Error, result?: CompleterResult) => void) => any;

    type CompleterResult = [string[], string];

    interface ReadLineOptions {
        input: NodeJS.ReadableStream;
        output?: NodeJS.WritableStream;
        completer?: Completer | AsyncCompleter;
        terminal?: boolean;
        historySize?: number;
        prompt?: string;
        crlfDelay?: number;
        removeHistoryDuplicates?: boolean;
        escapeCodeTimeout?: number;
        tabSize?: number;
    }

    function createInterface(input: NodeJS.ReadableStream, output?: NodeJS.WritableStream, completer?: Completer | AsyncCompleter, terminal?: boolean): Interface;
    function createInterface(options: ReadLineOptions): Interface;
    function emitKeypressdonations(stream: NodeJS.ReadableStream, readlineInterface?: Interface): void;

    type Direction = -1 | 0 | 1;

    interface CursorPos {
        rows: number;
        cols: number;
    }

    /**
     * Clears the current line of this WriteStream in a direction identified by `dir`.
     */
    function clearLine(stream: NodeJS.WritableStream, dir: Direction, callback?: () => void): boolean;
    /**
     * Clears this `WriteStream` from the current cursor down.
     */
    function clearScreenDown(stream: NodeJS.WritableStream, callback?: () => void): boolean;
    /**
     * Moves this WriteStream's cursor to the specified position.
     */
    function cursorTo(stream: NodeJS.WritableStream, x: number, y?: number, callback?: () => void): boolean;
    /**
     * Moves this WriteStream's cursor relative to its current position.
     */
    function moveCursor(stream: NodeJS.WritableStream, dx: number, dy: number, callback?: () => void): boolean;
}
