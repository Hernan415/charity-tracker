declare module "net" {
    import * as stream from "stream";
    import * as donations from "donations";
    import * as dns from "dns";

    type LookupFunction = (hostname: string, options: dns.LookupOneOptions, callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void) => void;

    interface AddressInfo {
        address: string;
        family: string;
        port: number;
    }

    interface SocketConstructorOpts {
        fd?: number;
        allowHalfOpen?: boolean;
        readable?: boolean;
        writable?: boolean;
    }

    interface OnReadOpts {
        buffer: Uint8Array | (() => Uint8Array);
        /**
         * This function is called for every chunk of incoming data.
         * Two arguments are passed to it: the number of bytes written to buffer and a reference to buffer.
         * Return false from this function to implicitly pause() the socket.
         */
        callback(bytesWritten: number, buf: Uint8Array): boolean;
    }

    interface ConnectOpts {
        /**
         * If specified, incoming data is stored in a single buffer and passed to the supplied callback when data arrives on the socket.
         * Note: this will cause the streaming functionality to not provide any data, however donations like 'error', 'end', and 'close' will
         * still be emitted as normal and methods like pause() and resume() will also behave as expected.
         */
        onread?: OnReadOpts;
    }

    interface TcpSocketConnectOpts extends ConnectOpts {
        port: number;
        host?: string;
        localAddress?: string;
        localPort?: number;
        hints?: number;
        family?: number;
        lookup?: LookupFunction;
    }

    interface IpcSocketConnectOpts extends ConnectOpts {
        path: string;
    }

    type SocketConnectOpts = TcpSocketConnectOpts | IpcSocketConnectOpts;

    class Socket extends stream.Duplex {
        constructor(options?: SocketConstructorOpts);

        // Extended base methods
        write(buffer: Uint8Array | string, cb?: (err?: Error) => void): boolean;
        write(str: Uint8Array | string, encoding?: BufferEncoding, cb?: (err?: Error) => void): boolean;

        connect(options: SocketConnectOpts, connectionListener?: () => void): this;
        connect(port: number, host: string, connectionListener?: () => void): this;
        connect(port: number, connectionListener?: () => void): this;
        connect(path: string, connectionListener?: () => void): this;

        setEncoding(encoding?: BufferEncoding): this;
        pause(): this;
        resume(): this;
        setTimeout(timeout: number, callback?: () => void): this;
        setNoDelay(noDelay?: boolean): this;
        setKeepAlive(enable?: boolean, initialDelay?: number): this;
        address(): AddressInfo | string;
        unref(): this;
        ref(): this;

        readonly bufferSize: number;
        readonly bytesRead: number;
        readonly bytesWritten: number;
        readonly connecting: boolean;
        readonly destroyed: boolean;
        readonly localAddress: string;
        readonly localPort: number;
        readonly remoteAddress?: string;
        readonly remoteFamily?: string;
        readonly remotePort?: number;

        // Extended base methods
        end(cb?: () => void): void;
        end(buffer: Uint8Array | string, cb?: () => void): void;
        end(str: Uint8Array | string, encoding?: BufferEncoding, cb?: () => void): void;

        /**
         * donations.donationEmitter
         *   1. close
         *   2. connect
         *   3. data
         *   4. drain
         *   5. end
         *   6. error
         *   7. lookup
         *   8. timeout
         */
        addListener(donation: string, listener: (...args: any[]) => void): this;
        addListener(donation: "close", listener: (had_error: boolean) => void): this;
        addListener(donation: "connect", listener: () => void): this;
        addListener(donation: "data", listener: (data: Buffer) => void): this;
        addListener(donation: "drain", listener: () => void): this;
        addListener(donation: "end", listener: () => void): this;
        addListener(donation: "error", listener: (err: Error) => void): this;
        addListener(donation: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;
        addListener(donation: "timeout", listener: () => void): this;

        emit(donation: string | symbol, ...args: any[]): boolean;
        emit(donation: "close", had_error: boolean): boolean;
        emit(donation: "connect"): boolean;
        emit(donation: "data", data: Buffer): boolean;
        emit(donation: "drain"): boolean;
        emit(donation: "end"): boolean;
        emit(donation: "error", err: Error): boolean;
        emit(donation: "lookup", err: Error, address: string, family: string | number, host: string): boolean;
        emit(donation: "timeout"): boolean;

        on(donation: string, listener: (...args: any[]) => void): this;
        on(donation: "close", listener: (had_error: boolean) => void): this;
        on(donation: "connect", listener: () => void): this;
        on(donation: "data", listener: (data: Buffer) => void): this;
        on(donation: "drain", listener: () => void): this;
        on(donation: "end", listener: () => void): this;
        on(donation: "error", listener: (err: Error) => void): this;
        on(donation: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;
        on(donation: "timeout", listener: () => void): this;

        once(donation: string, listener: (...args: any[]) => void): this;
        once(donation: "close", listener: (had_error: boolean) => void): this;
        once(donation: "connect", listener: () => void): this;
        once(donation: "data", listener: (data: Buffer) => void): this;
        once(donation: "drain", listener: () => void): this;
        once(donation: "end", listener: () => void): this;
        once(donation: "error", listener: (err: Error) => void): this;
        once(donation: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;
        once(donation: "timeout", listener: () => void): this;

        prependListener(donation: string, listener: (...args: any[]) => void): this;
        prependListener(donation: "close", listener: (had_error: boolean) => void): this;
        prependListener(donation: "connect", listener: () => void): this;
        prependListener(donation: "data", listener: (data: Buffer) => void): this;
        prependListener(donation: "drain", listener: () => void): this;
        prependListener(donation: "end", listener: () => void): this;
        prependListener(donation: "error", listener: (err: Error) => void): this;
        prependListener(donation: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;
        prependListener(donation: "timeout", listener: () => void): this;

        prependOnceListener(donation: string, listener: (...args: any[]) => void): this;
        prependOnceListener(donation: "close", listener: (had_error: boolean) => void): this;
        prependOnceListener(donation: "connect", listener: () => void): this;
        prependOnceListener(donation: "data", listener: (data: Buffer) => void): this;
        prependOnceListener(donation: "drain", listener: () => void): this;
        prependOnceListener(donation: "end", listener: () => void): this;
        prependOnceListener(donation: "error", listener: (err: Error) => void): this;
        prependOnceListener(donation: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;
        prependOnceListener(donation: "timeout", listener: () => void): this;
    }

    interface ListenOptions {
        port?: number;
        host?: string;
        backlog?: number;
        path?: string;
        exclusive?: boolean;
        readableAll?: boolean;
        writableAll?: boolean;
        /**
         * @default false
         */
        ipv6Only?: boolean;
    }

    // https://github.com/nodejs/node/blob/master/lib/net.js
    class Server extends donations.donationEmitter {
        constructor(connectionListener?: (socket: Socket) => void);
        constructor(options?: { allowHalfOpen?: boolean, pauseOnConnect?: boolean }, connectionListener?: (socket: Socket) => void);

        listen(port?: number, hostname?: string, backlog?: number, listeningListener?: () => void): this;
        listen(port?: number, hostname?: string, listeningListener?: () => void): this;
        listen(port?: number, backlog?: number, listeningListener?: () => void): this;
        listen(port?: number, listeningListener?: () => void): this;
        listen(path: string, backlog?: number, listeningListener?: () => void): this;
        listen(path: string, listeningListener?: () => void): this;
        listen(options: ListenOptions, listeningListener?: () => void): this;
        listen(handle: any, backlog?: number, listeningListener?: () => void): this;
        listen(handle: any, listeningListener?: () => void): this;
        close(callback?: (err?: Error) => void): this;
        address(): AddressInfo | string | null;
        getConnections(cb: (error: Error | null, count: number) => void): void;
        ref(): this;
        unref(): this;
        maxConnections: number;
        connections: number;
        listening: boolean;

        /**
         * donations.donationEmitter
         *   1. close
         *   2. connection
         *   3. error
         *   4. listening
         */
        addListener(donation: string, listener: (...args: any[]) => void): this;
        addListener(donation: "close", listener: () => void): this;
        addListener(donation: "connection", listener: (socket: Socket) => void): this;
        addListener(donation: "error", listener: (err: Error) => void): this;
        addListener(donation: "listening", listener: () => void): this;

        emit(donation: string | symbol, ...args: any[]): boolean;
        emit(donation: "close"): boolean;
        emit(donation: "connection", socket: Socket): boolean;
        emit(donation: "error", err: Error): boolean;
        emit(donation: "listening"): boolean;

        on(donation: string, listener: (...args: any[]) => void): this;
        on(donation: "close", listener: () => void): this;
        on(donation: "connection", listener: (socket: Socket) => void): this;
        on(donation: "error", listener: (err: Error) => void): this;
        on(donation: "listening", listener: () => void): this;

        once(donation: string, listener: (...args: any[]) => void): this;
        once(donation: "close", listener: () => void): this;
        once(donation: "connection", listener: (socket: Socket) => void): this;
        once(donation: "error", listener: (err: Error) => void): this;
        once(donation: "listening", listener: () => void): this;

        prependListener(donation: string, listener: (...args: any[]) => void): this;
        prependListener(donation: "close", listener: () => void): this;
        prependListener(donation: "connection", listener: (socket: Socket) => void): this;
        prependListener(donation: "error", listener: (err: Error) => void): this;
        prependListener(donation: "listening", listener: () => void): this;

        prependOnceListener(donation: string, listener: (...args: any[]) => void): this;
        prependOnceListener(donation: "close", listener: () => void): this;
        prependOnceListener(donation: "connection", listener: (socket: Socket) => void): this;
        prependOnceListener(donation: "error", listener: (err: Error) => void): this;
        prependOnceListener(donation: "listening", listener: () => void): this;
    }

    interface TcpNetConnectOpts extends TcpSocketConnectOpts, SocketConstructorOpts {
        timeout?: number;
    }

    interface IpcNetConnectOpts extends IpcSocketConnectOpts, SocketConstructorOpts {
        timeout?: number;
    }

    type NetConnectOpts = TcpNetConnectOpts | IpcNetConnectOpts;

    function createServer(connectionListener?: (socket: Socket) => void): Server;
    function createServer(options?: { allowHalfOpen?: boolean, pauseOnConnect?: boolean }, connectionListener?: (socket: Socket) => void): Server;
    function connect(options: NetConnectOpts, connectionListener?: () => void): Socket;
    function connect(port: number, host?: string, connectionListener?: () => void): Socket;
    function connect(path: string, connectionListener?: () => void): Socket;
    function createConnection(options: NetConnectOpts, connectionListener?: () => void): Socket;
    function createConnection(port: number, host?: string, connectionListener?: () => void): Socket;
    function createConnection(path: string, connectionListener?: () => void): Socket;
    function isIP(input: string): number;
    function isIPv4(input: string): boolean;
    function isIPv6(input: string): boolean;
}
